The sliding window technique is commonly used to solve a variety of problems, particularly those involving arrays or strings. Here is a list of questions that can be solved using the sliding window technique:

### Fixed-Size Sliding Window Problems

1. **Maximum Sum Subarray of Size `K`**
   - Find the maximum sum of any subarray of size `K`.

2. **Minimum Sum Subarray of Size `K`**
   - Find the minimum sum of any subarray of size `K`.

3. **Longest Subarray of Ones After K Flips**
   - Given a binary array, find the longest subarray of 1s that can be obtained by flipping at most `K` 0s.

### Variable-Size Sliding Window Problems

4. **Longest Substring with At Most `K` Distinct Characters**
   - Given a string, find the length of the longest substring that contains at most `K` distinct characters.

5. **Longest Substring with Exactly `K` Distinct Characters**
   - Given a string, find the length of the longest substring that contains exactly `K` distinct characters.

6. **Longest Substring Without Repeating Characters**
   - Given a string, find the length of the longest substring without repeating characters.

7. **Smallest Subarray with Sum Greater Than or Equal to `S`**
   - Given an array of positive integers, find the length of the smallest subarray whose sum is greater than or equal to a given number `S`.

8. **Maximum Sum Subarray of Size Less Than or Equal to `K`**
   - Given an array, find the maximum sum of any subarray with size less than or equal to `K`.

9. **Longest Subarray with Sum at Most `S`**
   - Given an array, find the length of the longest subarray with sum at most `S`.

10. **Sliding Window Maximum**
    - Given an array and an integer `K`, find the maximum element in every contiguous subarray of size `K`.

11. **Sliding Window Minimum**
    - Given an array and an integer `K`, find the minimum element in every contiguous subarray of size `K`.

12. **Count of Anagrams in a String**
    - Given a string and a pattern, find the count of anagrams of the pattern in the string.

13. **Longest Subarray with Absolute Difference Less Than or Equal to Limit**
    - Given an array of integers and an integer limit, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to the limit.

14. **Longest Subarray with Sum Divisible by `K`**
    - Given an array of integers, find the length of the longest subarray with a sum divisible by `K`.

15. **Maximum Consecutive Ones III**
    - Given a binary array `nums` and an integer `K`, find the maximum number of consecutive 1s in the array if you can flip at most `K` 0s.

16. **Longest Subarray with Sum Equals `K`**
    - Given an array of integers and an integer `K`, find the length of the longest subarray that sums to `K`.

17. **Fruit Into Baskets (Longest Subarray with At Most Two Distinct Elements)**
    - Given an array representing types of fruits, find the length of the longest subarray with at most two distinct types of fruits.

### Example Problems with Code

Here are some example problems with code to illustrate the sliding window technique:

#### 1. Maximum Sum Subarray of Size `K`
```java
public class MaximumSumSubarrayOfSizeK {
    public static int findMaxSumSubarray(int[] arr, int k) {
        int maxSum = 0, windowSum = 0;

        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }

        maxSum = windowSum;

        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            maxSum = Math.max(maxSum, windowSum);
        }

        return maxSum;
    }

    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 1, 3, 2};
        int k = 3;
        System.out.println("Maximum sum of subarray of size " + k + ": " + findMaxSumSubarray(arr, k)); // Output: 9
    }
}
```

#### 2. Longest Substring with At Most `K` Distinct Characters
```java
import java.util.HashMap;
import java.util.Map;

public class LongestSubstringKDistinct {
    public static int longestSubstringKDistinct(String s, int k) {
        if (s == null || s.length() == 0 || k == 0) {
            return 0;
        }

        int left = 0, maxLength = 0;
        Map<Character, Integer> charCountMap = new HashMap<>();

        for (int right = 0; right < s.length(); right++) {
            char rightChar = s.charAt(right);
            charCountMap.put(rightChar, charCountMap.getOrDefault(rightChar, 0) + 1);

            while (charCountMap.size() > k) {
                char leftChar = s.charAt(left);
                charCountMap.put(leftChar, charCountMap.get(leftChar) - 1);
                if (charCountMap.get(leftChar) == 0) {
                    charCountMap.remove(leftChar);
                }
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    public static void main(String[] args) {
        String s = "eceba";
        int k = 2;
        System.out.println("Longest substring with " + k + " distinct characters: " + longestSubstringKDistinct(s, k)); // Output: 3 ("ece")
    }
}
```

These examples illustrate how the sliding window technique can be applied to solve different types of problems efficiently.


Here are some common problems solved using the sliding window technique, along with their solutions in Java:

### 1. Maximum Sum Subarray of Size `K`

**Problem**: Find the maximum sum of any subarray of size `K`.

**Solution**:
```java
public class MaximumSumSubarrayOfSizeK {
    public static int findMaxSumSubarray(int[] arr, int k) {
        int maxSum = 0, windowSum = 0;

        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }

        maxSum = windowSum;

        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            maxSum = Math.max(maxSum, windowSum);
        }

        return maxSum;
    }

    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 1, 3, 2};
        int k = 3;
        System.out.println("Maximum sum of subarray of size " + k + ": " + findMaxSumSubarray(arr, k)); // Output: 9
    }
}
```

### 2. Longest Substring with At Most `K` Distinct Characters

**Problem**: Find the length of the longest substring that contains at most `K` distinct characters.

**Solution**:
```java
import java.util.HashMap;
import java.util.Map;

public class LongestSubstringKDistinct {
    public static int longestSubstringKDistinct(String s, int k) {
        if (s == null || s.length() == 0 || k == 0) {
            return 0;
        }

        int left = 0, maxLength = 0;
        Map<Character, Integer> charCountMap = new HashMap<>();

        for (int right = 0; right < s.length(); right++) {
            char rightChar = s.charAt(right);
            charCountMap.put(rightChar, charCountMap.getOrDefault(rightChar, 0) + 1);

            while (charCountMap.size() > k) {
                char leftChar = s.charAt(left);
                charCountMap.put(leftChar, charCountMap.get(leftChar) - 1);
                if (charCountMap.get(leftChar) == 0) {
                    charCountMap.remove(leftChar);
                }
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    public static void main(String[] args) {
        String s = "eceba";
        int k = 2;
        System.out.println("Longest substring with " + k + " distinct characters: " + longestSubstringKDistinct(s, k)); // Output: 3 ("ece")
    }
}
```

### 3. Smallest Subarray with Sum Greater Than or Equal to `S`

**Problem**: Find the length of the smallest subarray whose sum is greater than or equal to a given number `S`.

**Solution**:
```java
public class SmallestSubarrayWithSum {
    public static int minSubArrayLen(int s, int[] nums) {
        int minLength = Integer.MAX_VALUE;
        int left = 0, sum = 0;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            while (sum >= s) {
                minLength = Math.max(minLength, right - left + 1);
                sum -= nums[left++];
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }

    public static void main(String[] args) {
        int s = 7;
        int[] nums = {2, 3, 1, 2, 4, 3};
        System.out.println("Smallest subarray length: " + minSubArrayLen(s, nums)); // Output: 2
    }
}
```

### 4. Longest Substring Without Repeating Characters

**Problem**: Find the length of the longest substring without repeating characters.

**Solution**:
```java
import java.util.HashSet;
import java.util.Set;

public class LongestSubstringWithoutRepeating {
    public static int lengthOfLongestSubstring(String s) {
        Set<Character> charSet = new HashSet<>();
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            while (charSet.contains(s.charAt(right))) {
                charSet.remove(s.charAt(left++));
            }
            charSet.add(s.charAt(right));
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    public static void main(String[] args) {
        String s = "abcabcbb";
        System.out.println("Length of longest substring without repeating characters: " + lengthOfLongestSubstring(s)); // Output: 3 ("abc")
    }
}
```

### 5. Sliding Window Maximum

**Problem**: Given an array and an integer `K`, find the maximum element in every contiguous subarray of size `K`.

**Solution**:
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class SlidingWindowMaximum {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) {
            return new int[0];
        }

        int n = nums.length;
        int[] result = new int[n - k + 1];
        int ri = 0;
        Deque<Integer> deque = new ArrayDeque<>();

        for (int i = 0; i < nums.length; i++) {
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }

            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);
            if (i >= k - 1) {
                result[ri++] = nums[deque.peek()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;
        int[] result = maxSlidingWindow(nums, k);
        System.out.print("Maximum values in each sliding window: ");
        for (int num : result) {
            System.out.print(num + " "); // Output: 3 3 5 5 6 7
        }
    }
}
```

### 6. Longest Subarray of Ones After K Flips

**Problem**: Given a binary array, find the longest subarray of 1s that can be obtained by flipping at most `K` 0s.

**Solution**:
```java
public class LongestSubarrayOnesAfterKFlips {
    public static int longestOnes(int[] A, int K) {
        int left = 0, right;
        for (right = 0; right < A.length; right++) {
            if (A[right] == 0) K--;
            if (K < 0) {
                if (A[left] == 0) K++;
                left++;
            }
        }
        return right - left;
    }

    public static void main(String[] args) {
        int[] A = {1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0};
        int K = 2;
        System.out.println("Longest subarray of 1s after " + K + " flips: " + longestOnes(A, K)); // Output: 6
    }
}
```

### 7. Fruit Into Baskets (Longest Subarray with At Most Two Distinct Elements)

**Problem**: Given an array representing types of fruits, find the length of the longest subarray with at most two distinct types of fruits.

**Solution**:
```java
import java.util.HashMap;
import java.util.Map;

public class FruitIntoBaskets {
    public static int totalFruit(int[] tree) {
        Map<Integer, Integer> count = new HashMap<>();
        int i = 0, max = 0;

        for (int j = 0; j < tree.length; j++) {
            count.put(tree[j], count.getOrDefault(tree[j], 0) + 1);

            while (count.size() > 2) {
                count.put(tree[i], count.get(tree[i]) - 1);
                if (count.get(tree[i]) == 0) {
                    count.remove(tree[i]);
                }
                i++;
            }

            max = Math.max(max, j - i + 1);
        }

        return max;
    }

    public static void main(String[] args) {
        int[] tree = {1, 2, 1, 2, 3, 2, 2, 2, 3};
        System.out.println("Total fruits that can be collected: " + totalFruit(tree)); // Output: 5
    }
}
```

These problems and solutions illustrate how the sliding window technique can be effectively applied to a wide range of problems involving arrays and strings.
